/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_aframe-components_js"],{

/***/ "./components/aframe-components.js":
/*!*****************************************!*\
  !*** ./components/aframe-components.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Only run this code on the client side\nif (true) {\n    // Wait for A-Frame to be ready\n    window.addEventListener('load', ()=>{\n        if (typeof AFRAME === 'undefined') {\n            console.warn('A-Frame not loaded yet');\n            return;\n        }\n        // Import THREE from A-Frame to use for vector calculations\n        const THREE = AFRAME.THREE;\n        AFRAME.registerComponent('custom-controls', {\n            init: function() {\n                const camera = this.el;\n                let moveForward = false;\n                let moveBackward = false;\n                let moveLeft = false;\n                let moveRight = false;\n                const speed = 0.15;\n                // Create D-pad container\n                const dpadContainer = document.createElement('div');\n                dpadContainer.className = 'dpad-container';\n                const dpad = document.createElement('div');\n                dpad.className = 'dpad';\n                // Create D-pad buttons with icons\n                const buttons = {\n                    up: createButton('dpad-up', '↑'),\n                    right: createButton('dpad-right', '→'),\n                    down: createButton('dpad-down', '↓'),\n                    left: createButton('dpad-left', '←')\n                };\n                function createButton(className, icon) {\n                    const button = document.createElement('div');\n                    button.className = \"dpad-button \".concat(className);\n                    button.innerHTML = icon;\n                    dpad.appendChild(button);\n                    return button;\n                }\n                // Add touch event listeners with prevent default\n                const addTouchListeners = (element, callback)=>{\n                    element.addEventListener('touchstart', (e)=>{\n                        e.preventDefault();\n                        callback(true);\n                    }, {\n                        passive: false\n                    });\n                    element.addEventListener('touchend', (e)=>{\n                        e.preventDefault();\n                        callback(false);\n                    }, {\n                        passive: false\n                    });\n                };\n                addTouchListeners(buttons.up, (val)=>moveForward = val);\n                addTouchListeners(buttons.down, (val)=>moveBackward = val);\n                addTouchListeners(buttons.left, (val)=>moveLeft = val);\n                addTouchListeners(buttons.right, (val)=>moveRight = val);\n                dpadContainer.appendChild(dpad);\n                document.body.appendChild(dpadContainer);\n                // Movement animation\n                this.tick = function() {\n                    const rotation = camera.object3D.rotation;\n                    const position = camera.object3D.position;\n                    // Calculate forward direction based on camera rotation\n                    const direction = new THREE.Vector3();\n                    camera.object3D.getWorldDirection(direction);\n                    if (moveForward) {\n                        position.x += direction.x * speed;\n                        position.z += direction.z * speed;\n                    }\n                    if (moveBackward) {\n                        position.x -= direction.x * speed;\n                        position.z -= direction.z * speed;\n                    }\n                    if (moveLeft) {\n                        position.x += Math.cos(rotation.y + Math.PI / 2) * speed;\n                        position.z += Math.sin(rotation.y + Math.PI / 2) * speed;\n                    }\n                    if (moveRight) {\n                        position.x += Math.cos(rotation.y - Math.PI / 2) * speed;\n                        position.z += Math.sin(rotation.y - Math.PI / 2) * speed;\n                    }\n                };\n            }\n        });\n        AFRAME.registerComponent('parking-lot-texture', {\n            init: function() {\n                const canvas = document.getElementById('parkingTexture');\n                if (!canvas) return;\n                const ctx = canvas.getContext('2d');\n                // Set background to white\n                ctx.fillStyle = '#FFFFFF';\n                ctx.fillRect(0, 0, 512, 512);\n                // Draw parking lines\n                ctx.strokeStyle = '#333333';\n                ctx.lineWidth = 4;\n                // Draw straight lines\n                for(let i = 0; i < 512; i += 64){\n                    // Vertical lines\n                    ctx.beginPath();\n                    ctx.moveTo(i, 0);\n                    ctx.lineTo(i, 512);\n                    ctx.stroke();\n                    // Horizontal lines\n                    ctx.beginPath();\n                    ctx.moveTo(0, i);\n                    ctx.lineTo(512, i);\n                    ctx.stroke();\n                }\n                // Draw squiggles\n                ctx.strokeStyle = '#222222';\n                ctx.lineWidth = 2;\n                for(let i = 0; i < 10; i++){\n                    ctx.beginPath();\n                    ctx.moveTo(Math.random() * 512, Math.random() * 512);\n                    for(let j = 0; j < 5; j++){\n                        ctx.quadraticCurveTo(Math.random() * 512, Math.random() * 512, Math.random() * 512, Math.random() * 512);\n                    }\n                    ctx.stroke();\n                }\n            }\n        });\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2FmcmFtZS1jb21wb25lbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHdDQUF3QztBQUN4QyxJQUFJLElBQTZCLEVBQUU7SUFDakMsK0JBQStCO0lBQy9CQSxPQUFPQyxnQkFBZ0IsQ0FBQyxRQUFRO1FBQzlCLElBQUksT0FBT0MsV0FBVyxhQUFhO1lBQ2pDQyxRQUFRQyxJQUFJLENBQUM7WUFDYjtRQUNGO1FBRUEsMkRBQTJEO1FBQzNELE1BQU1DLFFBQVFILE9BQU9HLEtBQUs7UUFFMUJILE9BQU9JLGlCQUFpQixDQUFDLG1CQUFtQjtZQUMxQ0MsTUFBTTtnQkFDSixNQUFNQyxTQUFTLElBQUksQ0FBQ0MsRUFBRTtnQkFDdEIsSUFBSUMsY0FBYztnQkFDbEIsSUFBSUMsZUFBZTtnQkFDbkIsSUFBSUMsV0FBVztnQkFDZixJQUFJQyxZQUFZO2dCQUNoQixNQUFNQyxRQUFRO2dCQUVkLHlCQUF5QjtnQkFDekIsTUFBTUMsZ0JBQWdCQyxTQUFTQyxhQUFhLENBQUM7Z0JBQzdDRixjQUFjRyxTQUFTLEdBQUc7Z0JBRTFCLE1BQU1DLE9BQU9ILFNBQVNDLGFBQWEsQ0FBQztnQkFDcENFLEtBQUtELFNBQVMsR0FBRztnQkFFakIsa0NBQWtDO2dCQUNsQyxNQUFNRSxVQUFVO29CQUNkQyxJQUFJQyxhQUFhLFdBQVc7b0JBQzVCQyxPQUFPRCxhQUFhLGNBQWM7b0JBQ2xDRSxNQUFNRixhQUFhLGFBQWE7b0JBQ2hDRyxNQUFNSCxhQUFhLGFBQWE7Z0JBQ2xDO2dCQUVBLFNBQVNBLGFBQWFKLFNBQVMsRUFBRVEsSUFBSTtvQkFDbkMsTUFBTUMsU0FBU1gsU0FBU0MsYUFBYSxDQUFDO29CQUN0Q1UsT0FBT1QsU0FBUyxHQUFHLGVBQXlCLE9BQVZBO29CQUNsQ1MsT0FBT0MsU0FBUyxHQUFHRjtvQkFDbkJQLEtBQUtVLFdBQVcsQ0FBQ0Y7b0JBQ2pCLE9BQU9BO2dCQUNUO2dCQUVBLGlEQUFpRDtnQkFDakQsTUFBTUcsb0JBQW9CLENBQUNDLFNBQVNDO29CQUNsQ0QsUUFBUTlCLGdCQUFnQixDQUFDLGNBQWMsQ0FBQ2dDO3dCQUN0Q0EsRUFBRUMsY0FBYzt3QkFDaEJGLFNBQVM7b0JBQ1gsR0FBRzt3QkFBRUcsU0FBUztvQkFBTTtvQkFFcEJKLFFBQVE5QixnQkFBZ0IsQ0FBQyxZQUFZLENBQUNnQzt3QkFDcENBLEVBQUVDLGNBQWM7d0JBQ2hCRixTQUFTO29CQUNYLEdBQUc7d0JBQUVHLFNBQVM7b0JBQU07Z0JBQ3RCO2dCQUVBTCxrQkFBa0JWLFFBQVFDLEVBQUUsRUFBRSxDQUFDZSxNQUFRMUIsY0FBYzBCO2dCQUNyRE4sa0JBQWtCVixRQUFRSSxJQUFJLEVBQUUsQ0FBQ1ksTUFBUXpCLGVBQWV5QjtnQkFDeEROLGtCQUFrQlYsUUFBUUssSUFBSSxFQUFFLENBQUNXLE1BQVF4QixXQUFXd0I7Z0JBQ3BETixrQkFBa0JWLFFBQVFHLEtBQUssRUFBRSxDQUFDYSxNQUFRdkIsWUFBWXVCO2dCQUV0RHJCLGNBQWNjLFdBQVcsQ0FBQ1Y7Z0JBQzFCSCxTQUFTcUIsSUFBSSxDQUFDUixXQUFXLENBQUNkO2dCQUUxQixxQkFBcUI7Z0JBQ3JCLElBQUksQ0FBQ3VCLElBQUksR0FBRztvQkFDVixNQUFNQyxXQUFXL0IsT0FBT2dDLFFBQVEsQ0FBQ0QsUUFBUTtvQkFDekMsTUFBTUUsV0FBV2pDLE9BQU9nQyxRQUFRLENBQUNDLFFBQVE7b0JBRXpDLHVEQUF1RDtvQkFDdkQsTUFBTUMsWUFBWSxJQUFJckMsTUFBTXNDLE9BQU87b0JBQ25DbkMsT0FBT2dDLFFBQVEsQ0FBQ0ksaUJBQWlCLENBQUNGO29CQUVsQyxJQUFJaEMsYUFBYTt3QkFDZitCLFNBQVNJLENBQUMsSUFBSUgsVUFBVUcsQ0FBQyxHQUFHL0I7d0JBQzVCMkIsU0FBU0ssQ0FBQyxJQUFJSixVQUFVSSxDQUFDLEdBQUdoQztvQkFDOUI7b0JBQ0EsSUFBSUgsY0FBYzt3QkFDaEI4QixTQUFTSSxDQUFDLElBQUlILFVBQVVHLENBQUMsR0FBRy9CO3dCQUM1QjJCLFNBQVNLLENBQUMsSUFBSUosVUFBVUksQ0FBQyxHQUFHaEM7b0JBQzlCO29CQUNBLElBQUlGLFVBQVU7d0JBQ1o2QixTQUFTSSxDQUFDLElBQUlFLEtBQUtDLEdBQUcsQ0FBQ1QsU0FBU1UsQ0FBQyxHQUFHRixLQUFLRyxFQUFFLEdBQUMsS0FBS3BDO3dCQUNqRDJCLFNBQVNLLENBQUMsSUFBSUMsS0FBS0ksR0FBRyxDQUFDWixTQUFTVSxDQUFDLEdBQUdGLEtBQUtHLEVBQUUsR0FBQyxLQUFLcEM7b0JBQ25EO29CQUNBLElBQUlELFdBQVc7d0JBQ2I0QixTQUFTSSxDQUFDLElBQUlFLEtBQUtDLEdBQUcsQ0FBQ1QsU0FBU1UsQ0FBQyxHQUFHRixLQUFLRyxFQUFFLEdBQUMsS0FBS3BDO3dCQUNqRDJCLFNBQVNLLENBQUMsSUFBSUMsS0FBS0ksR0FBRyxDQUFDWixTQUFTVSxDQUFDLEdBQUdGLEtBQUtHLEVBQUUsR0FBQyxLQUFLcEM7b0JBQ25EO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBWixPQUFPSSxpQkFBaUIsQ0FBQyx1QkFBdUI7WUFDOUNDLE1BQU07Z0JBQ0osTUFBTTZDLFNBQVNwQyxTQUFTcUMsY0FBYyxDQUFDO2dCQUN2QyxJQUFJLENBQUNELFFBQVE7Z0JBRWIsTUFBTUUsTUFBTUYsT0FBT0csVUFBVSxDQUFDO2dCQUU5QiwwQkFBMEI7Z0JBQzFCRCxJQUFJRSxTQUFTLEdBQUc7Z0JBQ2hCRixJQUFJRyxRQUFRLENBQUMsR0FBRyxHQUFHLEtBQUs7Z0JBRXhCLHFCQUFxQjtnQkFDckJILElBQUlJLFdBQVcsR0FBRztnQkFDbEJKLElBQUlLLFNBQVMsR0FBRztnQkFFaEIsc0JBQXNCO2dCQUN0QixJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLQSxLQUFLLEdBQUk7b0JBQy9CLGlCQUFpQjtvQkFDakJOLElBQUlPLFNBQVM7b0JBQ2JQLElBQUlRLE1BQU0sQ0FBQ0YsR0FBRztvQkFDZE4sSUFBSVMsTUFBTSxDQUFDSCxHQUFHO29CQUNkTixJQUFJVSxNQUFNO29CQUVWLG1CQUFtQjtvQkFDbkJWLElBQUlPLFNBQVM7b0JBQ2JQLElBQUlRLE1BQU0sQ0FBQyxHQUFHRjtvQkFDZE4sSUFBSVMsTUFBTSxDQUFDLEtBQUtIO29CQUNoQk4sSUFBSVUsTUFBTTtnQkFDWjtnQkFFQSxpQkFBaUI7Z0JBQ2pCVixJQUFJSSxXQUFXLEdBQUc7Z0JBQ2xCSixJQUFJSyxTQUFTLEdBQUc7Z0JBQ2hCLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7b0JBQzFCTixJQUFJTyxTQUFTO29CQUNiUCxJQUFJUSxNQUFNLENBQUNmLEtBQUtrQixNQUFNLEtBQUssS0FBS2xCLEtBQUtrQixNQUFNLEtBQUs7b0JBQ2hELElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7d0JBQ3pCWixJQUFJYSxnQkFBZ0IsQ0FDbEJwQixLQUFLa0IsTUFBTSxLQUFLLEtBQUtsQixLQUFLa0IsTUFBTSxLQUFLLEtBQ3JDbEIsS0FBS2tCLE1BQU0sS0FBSyxLQUFLbEIsS0FBS2tCLE1BQU0sS0FBSztvQkFFekM7b0JBQ0FYLElBQUlVLE1BQU07Z0JBQ1o7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21ybWV0YXZlcnNlL0NvZGUvYnVmZmJsZXUvY29tcG9uZW50cy9hZnJhbWUtY29tcG9uZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPbmx5IHJ1biB0aGlzIGNvZGUgb24gdGhlIGNsaWVudCBzaWRlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gV2FpdCBmb3IgQS1GcmFtZSB0byBiZSByZWFkeVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICBpZiAodHlwZW9mIEFGUkFNRSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybignQS1GcmFtZSBub3QgbG9hZGVkIHlldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEltcG9ydCBUSFJFRSBmcm9tIEEtRnJhbWUgdG8gdXNlIGZvciB2ZWN0b3IgY2FsY3VsYXRpb25zXG4gICAgY29uc3QgVEhSRUUgPSBBRlJBTUUuVEhSRUU7XG5cbiAgICBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ2N1c3RvbS1jb250cm9scycsIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5lbDtcbiAgICAgICAgbGV0IG1vdmVGb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIGxldCBtb3ZlQmFja3dhcmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG1vdmVMZWZ0ID0gZmFsc2U7XG4gICAgICAgIGxldCBtb3ZlUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3BlZWQgPSAwLjE1O1xuXG4gICAgICAgIC8vIENyZWF0ZSBELXBhZCBjb250YWluZXJcbiAgICAgICAgY29uc3QgZHBhZENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkcGFkQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdkcGFkLWNvbnRhaW5lcic7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkcGFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRwYWQuY2xhc3NOYW1lID0gJ2RwYWQnO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIEQtcGFkIGJ1dHRvbnMgd2l0aCBpY29uc1xuICAgICAgICBjb25zdCBidXR0b25zID0ge1xuICAgICAgICAgIHVwOiBjcmVhdGVCdXR0b24oJ2RwYWQtdXAnLCAn4oaRJyksXG4gICAgICAgICAgcmlnaHQ6IGNyZWF0ZUJ1dHRvbignZHBhZC1yaWdodCcsICfihpInKSxcbiAgICAgICAgICBkb3duOiBjcmVhdGVCdXR0b24oJ2RwYWQtZG93bicsICfihpMnKSxcbiAgICAgICAgICBsZWZ0OiBjcmVhdGVCdXR0b24oJ2RwYWQtbGVmdCcsICfihpAnKVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvbihjbGFzc05hbWUsIGljb24pIHtcbiAgICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBidXR0b24uY2xhc3NOYW1lID0gYGRwYWQtYnV0dG9uICR7Y2xhc3NOYW1lfWA7XG4gICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IGljb247XG4gICAgICAgICAgZHBhZC5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICAgIHJldHVybiBidXR0b247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdG91Y2ggZXZlbnQgbGlzdGVuZXJzIHdpdGggcHJldmVudCBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFkZFRvdWNoTGlzdGVuZXJzID0gKGVsZW1lbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRUb3VjaExpc3RlbmVycyhidXR0b25zLnVwLCAodmFsKSA9PiBtb3ZlRm9yd2FyZCA9IHZhbCk7XG4gICAgICAgIGFkZFRvdWNoTGlzdGVuZXJzKGJ1dHRvbnMuZG93biwgKHZhbCkgPT4gbW92ZUJhY2t3YXJkID0gdmFsKTtcbiAgICAgICAgYWRkVG91Y2hMaXN0ZW5lcnMoYnV0dG9ucy5sZWZ0LCAodmFsKSA9PiBtb3ZlTGVmdCA9IHZhbCk7XG4gICAgICAgIGFkZFRvdWNoTGlzdGVuZXJzKGJ1dHRvbnMucmlnaHQsICh2YWwpID0+IG1vdmVSaWdodCA9IHZhbCk7XG5cbiAgICAgICAgZHBhZENvbnRhaW5lci5hcHBlbmRDaGlsZChkcGFkKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcGFkQ29udGFpbmVyKTtcblxuICAgICAgICAvLyBNb3ZlbWVudCBhbmltYXRpb25cbiAgICAgICAgdGhpcy50aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjYW1lcmEub2JqZWN0M0Qucm90YXRpb247XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBjYW1lcmEub2JqZWN0M0QucG9zaXRpb247XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIGZvcndhcmQgZGlyZWN0aW9uIGJhc2VkIG9uIGNhbWVyYSByb3RhdGlvblxuICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgY2FtZXJhLm9iamVjdDNELmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKG1vdmVGb3J3YXJkKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi54ICs9IGRpcmVjdGlvbi54ICogc3BlZWQ7XG4gICAgICAgICAgICBwb3NpdGlvbi56ICs9IGRpcmVjdGlvbi56ICogc3BlZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb3ZlQmFja3dhcmQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnggLT0gZGlyZWN0aW9uLnggKiBzcGVlZDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnogLT0gZGlyZWN0aW9uLnogKiBzcGVlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vdmVMZWZ0KSB7XG4gICAgICAgICAgICBwb3NpdGlvbi54ICs9IE1hdGguY29zKHJvdGF0aW9uLnkgKyBNYXRoLlBJLzIpICogc3BlZWQ7XG4gICAgICAgICAgICBwb3NpdGlvbi56ICs9IE1hdGguc2luKHJvdGF0aW9uLnkgKyBNYXRoLlBJLzIpICogc3BlZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb3ZlUmlnaHQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnggKz0gTWF0aC5jb3Mocm90YXRpb24ueSAtIE1hdGguUEkvMikgKiBzcGVlZDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnogKz0gTWF0aC5zaW4ocm90YXRpb24ueSAtIE1hdGguUEkvMikgKiBzcGVlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3BhcmtpbmctbG90LXRleHR1cmUnLCB7XG4gICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmtpbmdUZXh0dXJlJyk7XG4gICAgICAgIGlmICghY2FudmFzKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBiYWNrZ3JvdW5kIHRvIHdoaXRlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI0ZGRkZGRic7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCA1MTIsIDUxMik7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHBhcmtpbmcgbGluZXNcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyMzMzMzMzMnO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gNDtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgc3RyYWlnaHQgbGluZXNcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDUxMjsgaSArPSA2NCkge1xuICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmVzXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oaSwgMCk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhpLCA1MTIpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmVzXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgaSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyg1MTIsIGkpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBzcXVpZ2dsZXNcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyMyMjIyMjInO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhNYXRoLnJhbmRvbSgpICogNTEyLCBNYXRoLnJhbmRvbSgpICogNTEyKTtcbiAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgNTsgaisrKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIDUxMiwgTWF0aC5yYW5kb20oKSAqIDUxMixcbiAgICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIDUxMiwgTWF0aC5yYW5kb20oKSAqIDUxMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSAiXSwibmFtZXMiOlsid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsIkFGUkFNRSIsImNvbnNvbGUiLCJ3YXJuIiwiVEhSRUUiLCJyZWdpc3RlckNvbXBvbmVudCIsImluaXQiLCJjYW1lcmEiLCJlbCIsIm1vdmVGb3J3YXJkIiwibW92ZUJhY2t3YXJkIiwibW92ZUxlZnQiLCJtb3ZlUmlnaHQiLCJzcGVlZCIsImRwYWRDb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJkcGFkIiwiYnV0dG9ucyIsInVwIiwiY3JlYXRlQnV0dG9uIiwicmlnaHQiLCJkb3duIiwibGVmdCIsImljb24iLCJidXR0b24iLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsImFkZFRvdWNoTGlzdGVuZXJzIiwiZWxlbWVudCIsImNhbGxiYWNrIiwiZSIsInByZXZlbnREZWZhdWx0IiwicGFzc2l2ZSIsInZhbCIsImJvZHkiLCJ0aWNrIiwicm90YXRpb24iLCJvYmplY3QzRCIsInBvc2l0aW9uIiwiZGlyZWN0aW9uIiwiVmVjdG9yMyIsImdldFdvcmxkRGlyZWN0aW9uIiwieCIsInoiLCJNYXRoIiwiY29zIiwieSIsIlBJIiwic2luIiwiY2FudmFzIiwiZ2V0RWxlbWVudEJ5SWQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImkiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJyYW5kb20iLCJqIiwicXVhZHJhdGljQ3VydmVUbyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/aframe-components.js\n"));

/***/ })

}]);