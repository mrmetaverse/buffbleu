/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_aframe-components_js"],{

/***/ "./components/aframe-components.js":
/*!*****************************************!*\
  !*** ./components/aframe-components.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Only run this code on the client side\nif (true) {\n    // Wait for A-Frame to be ready\n    window.addEventListener('load', ()=>{\n        if (typeof AFRAME === 'undefined') {\n            console.warn('A-Frame not loaded yet');\n            return;\n        }\n        // Import THREE from A-Frame to use for vector calculations\n        const THREE = AFRAME.THREE;\n        AFRAME.registerComponent('custom-controls', {\n            init: function() {\n                const camera = this.el;\n                let moveForward = false;\n                let moveBackward = false;\n                let moveLeft = false;\n                let moveRight = false;\n                const speed = 0.15;\n                // Create D-pad container\n                const dpadContainer = document.createElement('div');\n                dpadContainer.className = 'dpad-container';\n                const dpad = document.createElement('div');\n                dpad.className = 'dpad';\n                // Create D-pad buttons with icons\n                const buttons = {\n                    up: createButton('dpad-up', '↑'),\n                    right: createButton('dpad-right', '→'),\n                    down: createButton('dpad-down', '↓'),\n                    left: createButton('dpad-left', '←')\n                };\n                function createButton(className, icon) {\n                    const button = document.createElement('div');\n                    button.className = \"dpad-button \".concat(className);\n                    button.innerHTML = icon;\n                    dpad.appendChild(button);\n                    return button;\n                }\n                // Add touch event listeners with prevent default\n                const addTouchListeners = (element, callback)=>{\n                    element.addEventListener('touchstart', (e)=>{\n                        e.preventDefault();\n                        callback(true);\n                    }, {\n                        passive: false\n                    });\n                    element.addEventListener('touchend', (e)=>{\n                        e.preventDefault();\n                        callback(false);\n                    }, {\n                        passive: false\n                    });\n                };\n                addTouchListeners(buttons.up, (val)=>moveForward = val);\n                addTouchListeners(buttons.down, (val)=>moveBackward = val);\n                addTouchListeners(buttons.left, (val)=>moveLeft = val);\n                addTouchListeners(buttons.right, (val)=>moveRight = val);\n                dpadContainer.appendChild(dpad);\n                document.body.appendChild(dpadContainer);\n                // Movement animation\n                this.tick = function() {\n                    const rotation = camera.object3D.rotation;\n                    const position = camera.object3D.position;\n                    // Calculate forward direction based on camera rotation\n                    const direction = new THREE.Vector3();\n                    camera.object3D.getWorldDirection(direction);\n                    if (moveForward) {\n                        position.x += direction.x * speed;\n                        position.z += direction.z * speed;\n                    }\n                    if (moveBackward) {\n                        position.x -= direction.x * speed;\n                        position.z -= direction.z * speed;\n                    }\n                    if (moveLeft) {\n                        position.x += Math.cos(rotation.y + Math.PI / 2) * speed;\n                        position.z += Math.sin(rotation.y + Math.PI / 2) * speed;\n                    }\n                    if (moveRight) {\n                        position.x += Math.cos(rotation.y - Math.PI / 2) * speed;\n                        position.z += Math.sin(rotation.y - Math.PI / 2) * speed;\n                    }\n                };\n            }\n        });\n        AFRAME.registerComponent('parking-lot-texture', {\n            init: function() {\n                const canvas = document.getElementById('parkingTexture');\n                if (!canvas) return;\n                const ctx = canvas.getContext('2d');\n                // Set background to white\n                ctx.fillStyle = '#FFFFFF';\n                ctx.fillRect(0, 0, 512, 512);\n                // Draw parking lines\n                ctx.strokeStyle = '#333333';\n                ctx.lineWidth = 4;\n                // Draw straight lines\n                for(let i = 0; i < 512; i += 64){\n                    // Vertical lines\n                    ctx.beginPath();\n                    ctx.moveTo(i, 0);\n                    ctx.lineTo(i, 512);\n                    ctx.stroke();\n                    // Horizontal lines\n                    ctx.beginPath();\n                    ctx.moveTo(0, i);\n                    ctx.lineTo(512, i);\n                    ctx.stroke();\n                }\n                // Draw squiggles\n                ctx.strokeStyle = '#222222';\n                ctx.lineWidth = 2;\n                for(let i = 0; i < 10; i++){\n                    ctx.beginPath();\n                    ctx.moveTo(Math.random() * 512, Math.random() * 512);\n                    for(let j = 0; j < 5; j++){\n                        ctx.quadraticCurveTo(Math.random() * 512, Math.random() * 512, Math.random() * 512, Math.random() * 512);\n                    }\n                    ctx.stroke();\n                }\n            }\n        });\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUlRLE1BQU0sQ0FBQyxHQUFHRjtvQkFDZE4sSUFBSVMsTUFBTSxDQUFDLEtBQUtIO29CQUNoQk4sSUFBSVUsTUFBTTtnQkFDWjtnQkFFQSxpQkFBaUI7Z0JBQ2pCVixJQUFJSSxXQUFXLEdBQUc7Z0JBQ2xCSixJQUFJSyxTQUFTLEdBQUc7Z0JBQ2hCLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7b0JBQzFCTixJQUFJTyxTQUFTO29CQUNiUCxJQUFJUSxNQUFNLENBQUNmLEtBQUtrQixNQUFNLEtBQUssS0FBS2xCLEtBQUtrQixNQUFNLEtBQUs7b0JBQ2hELElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7d0JBQ3pCWixJQUFJYSxnQkFBZ0IsQ0FDbEJwQixLQUFLa0IsTUFBTSxLQUFLLEtBQUtsQixLQUFLa0IsTUFBTSxLQUFLLEtBQ3JDbEIsS0FBS2tCLE1BQU0sS0FBSyxLQUFLbEIsS0FBS2tCLE1BQU0sS0FBSztvQkFFekM7b0JBQ0FYLElBQUlVLE1BQU07Z0JBQ1o7WUFDRjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvbXJtZXRhdmVyc2UvQ29kZS9idWZmYmxldS9jb21wb25lbnRzL2FmcmFtZS1jb21wb25lbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9ubHkgcnVuIHRoaXMgY29kZSBvbiB0aGUgY2xpZW50IHNpZGVcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBXYWl0IGZvciBBLUZyYW1lIHRvIGJlIHJlYWR5XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgQUZSQU1FID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKCdBLUZyYW1lIG5vdCBsb2FkZWQgeWV0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW1wb3J0IFRIUkVFIGZyb20gQS1GcmFtZSB0byB1c2UgZm9yIHZlY3RvciBjYWxjdWxhdGlvbnNcbiAgICBjb25zdCBUSFJFRSA9IEFGUkFNRS5USFJFRTtcblxuICAgIEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnY3VzdG9tLWNvbnRyb2xzJywge1xuICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmVsO1xuICAgICAgICBsZXQgbW92ZUZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG1vdmVCYWNrd2FyZCA9IGZhbHNlO1xuICAgICAgICBsZXQgbW92ZUxlZnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG1vdmVSaWdodCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzcGVlZCA9IDAuMTU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIEQtcGFkIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBkcGFkQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRwYWRDb250YWluZXIuY2xhc3NOYW1lID0gJ2RwYWQtY29udGFpbmVyJztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRwYWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZHBhZC5jbGFzc05hbWUgPSAnZHBhZCc7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgRC1wYWQgYnV0dG9ucyB3aXRoIGljb25zXG4gICAgICAgIGNvbnN0IGJ1dHRvbnMgPSB7XG4gICAgICAgICAgdXA6IGNyZWF0ZUJ1dHRvbignZHBhZC11cCcsICfihpEnKSxcbiAgICAgICAgICByaWdodDogY3JlYXRlQnV0dG9uKCdkcGFkLXJpZ2h0JywgJ+KGkicpLFxuICAgICAgICAgIGRvd246IGNyZWF0ZUJ1dHRvbignZHBhZC1kb3duJywgJ+KGkycpLFxuICAgICAgICAgIGxlZnQ6IGNyZWF0ZUJ1dHRvbignZHBhZC1sZWZ0JywgJ+KGkCcpXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSwgaWNvbikge1xuICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBgZHBhZC1idXR0b24gJHtjbGFzc05hbWV9YDtcbiAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gaWNvbjtcbiAgICAgICAgICBkcGFkLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0b3VjaCBldmVudCBsaXN0ZW5lcnMgd2l0aCBwcmV2ZW50IGRlZmF1bHRcbiAgICAgICAgY29uc3QgYWRkVG91Y2hMaXN0ZW5lcnMgPSAoZWxlbWVudCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZFRvdWNoTGlzdGVuZXJzKGJ1dHRvbnMudXAsICh2YWwpID0+IG1vdmVGb3J3YXJkID0gdmFsKTtcbiAgICAgICAgYWRkVG91Y2hMaXN0ZW5lcnMoYnV0dG9ucy5kb3duLCAodmFsKSA9PiBtb3ZlQmFja3dhcmQgPSB2YWwpO1xuICAgICAgICBhZGRUb3VjaExpc3RlbmVycyhidXR0b25zLmxlZnQsICh2YWwpID0+IG1vdmVMZWZ0ID0gdmFsKTtcbiAgICAgICAgYWRkVG91Y2hMaXN0ZW5lcnMoYnV0dG9ucy5yaWdodCwgKHZhbCkgPT4gbW92ZVJpZ2h0ID0gdmFsKTtcblxuICAgICAgICBkcGFkQ29udGFpbmVyLmFwcGVuZENoaWxkKGRwYWQpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRwYWRDb250YWluZXIpO1xuXG4gICAgICAgIC8vIE1vdmVtZW50IGFuaW1hdGlvblxuICAgICAgICB0aGlzLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNhbWVyYS5vYmplY3QzRC5yb3RhdGlvbjtcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGNhbWVyYS5vYmplY3QzRC5wb3NpdGlvbjtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgZm9yd2FyZCBkaXJlY3Rpb24gYmFzZWQgb24gY2FtZXJhIHJvdGF0aW9uXG4gICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICBjYW1lcmEub2JqZWN0M0QuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAobW92ZUZvcndhcmQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnggKz0gZGlyZWN0aW9uLnggKiBzcGVlZDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnogKz0gZGlyZWN0aW9uLnogKiBzcGVlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vdmVCYWNrd2FyZCkge1xuICAgICAgICAgICAgcG9zaXRpb24ueCAtPSBkaXJlY3Rpb24ueCAqIHNwZWVkO1xuICAgICAgICAgICAgcG9zaXRpb24ueiAtPSBkaXJlY3Rpb24ueiAqIHNwZWVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW92ZUxlZnQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnggKz0gTWF0aC5jb3Mocm90YXRpb24ueSArIE1hdGguUEkvMikgKiBzcGVlZDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnogKz0gTWF0aC5zaW4ocm90YXRpb24ueSArIE1hdGguUEkvMikgKiBzcGVlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vdmVSaWdodCkge1xuICAgICAgICAgICAgcG9zaXRpb24ueCArPSBNYXRoLmNvcyhyb3RhdGlvbi55IC0gTWF0aC5QSS8yKSAqIHNwZWVkO1xuICAgICAgICAgICAgcG9zaXRpb24ueiArPSBNYXRoLnNpbihyb3RhdGlvbi55IC0gTWF0aC5QSS8yKSAqIHNwZWVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgncGFya2luZy1sb3QtdGV4dHVyZScsIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFya2luZ1RleHR1cmUnKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGJhY2tncm91bmQgdG8gd2hpdGVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjRkZGRkZGJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIDUxMiwgNTEyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgcGFya2luZyBsaW5lc1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzMzMzMzMyc7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSA0O1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBzdHJhaWdodCBsaW5lc1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgNTEyOyBpICs9IDY0KSB7XG4gICAgICAgICAgLy8gVmVydGljYWwgbGluZXNcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhpLCAwKTtcbiAgICAgICAgICBjdHgubGluZVRvKGksIDUxMik7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZXNcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbygwLCBpKTtcbiAgICAgICAgICBjdHgubGluZVRvKDUxMiwgaSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHNxdWlnZ2xlc1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzIyMjIyMic7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKE1hdGgucmFuZG9tKCkgKiA1MTIsIE1hdGgucmFuZG9tKCkgKiA1MTIpO1xuICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCA1OyBqKyspIHtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogNTEyLCBNYXRoLnJhbmRvbSgpICogNTEyLFxuICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogNTEyLCBNYXRoLnJhbmRvbSgpICogNTEyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59ICJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiQUZSQU1FIiwiY29uc29sZSIsIndhcm4iLCJUSFJFRSIsInJlZ2lzdGVyQ29tcG9uZW50IiwiaW5pdCIsImNhbWVyYSIsImVsIiwibW92ZUZvcndhcmQiLCJtb3ZlQmFja3dhcmQiLCJtb3ZlTGVmdCIsIm1vdmVSaWdodCIsInNwZWVkIiwiZHBhZENvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImRwYWQiLCJidXR0b25zIiwidXAiLCJjcmVhdGVCdXR0b24iLCJyaWdodCIsImRvd24iLCJsZWZ0IiwiaWNvbiIsImJ1dHRvbiIsImlubmVySFRNTCIsImFwcGVuZENoaWxkIiwiYWRkVG91Y2hMaXN0ZW5lcnMiLCJlbGVtZW50IiwiY2FsbGJhY2siLCJlIiwicHJldmVudERlZmF1bHQiLCJwYXNzaXZlIiwidmFsIiwiYm9keSIsInRpY2siLCJyb3RhdGlvbiIsIm9iamVjdDNEIiwicG9zaXRpb24iLCJkaXJlY3Rpb24iLCJWZWN0b3IzIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJ4IiwieiIsIk1hdGgiLCJjb3MiLCJ5IiwiUEkiLCJzaW4iLCJjYW52YXMiLCJnZXRFbGVtZW50QnlJZCIsImN0eCIsImdldENvbnRleHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiaSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsInJhbmRvbSIsImoiLCJxdWFkcmF0aWNDdXJ2ZVRvIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/aframe-components.js\n"));

/***/ })

}]);