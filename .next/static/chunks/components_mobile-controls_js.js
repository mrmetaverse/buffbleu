/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_mobile-controls_js"],{

/***/ "./components/mobile-controls.js":
/*!***************************************!*\
  !*** ./components/mobile-controls.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("const initMobileControls = ()=>{\n    if ( true && typeof AFRAME !== 'undefined') {\n        AFRAME.registerComponent('mobile-controls', {\n            init: function() {\n                if (!AFRAME.utils.device.isMobile()) return; // Only run on mobile\n                this.touchStartX = 0;\n                this.touchStartY = 0;\n                this.moving = false;\n                this.speed = 0.15;\n                // Create D-pad UI\n                const dpad = document.createElement('div');\n                dpad.id = 'mobile-dpad';\n                dpad.style.cssText = \"\\n          position: fixed;\\n          bottom: 20px;\\n          left: 20px;\\n          width: 150px;\\n          height: 150px;\\n          background: rgba(255, 255, 255, 0.3);\\n          border-radius: 50%;\\n          z-index: 9999;\\n          touch-action: none;\\n        \";\n                document.body.appendChild(dpad);\n                // Touch handlers for D-pad\n                dpad.addEventListener('touchstart', this.onTouchStart.bind(this));\n                dpad.addEventListener('touchmove', this.onTouchMove.bind(this));\n                dpad.addEventListener('touchend', this.onTouchEnd.bind(this));\n                // Pinch zoom handlers\n                document.addEventListener('touchstart', this.onPinchStart.bind(this));\n                document.addEventListener('touchmove', this.onPinchMove.bind(this));\n            },\n            onTouchStart: function(evt) {\n                evt.preventDefault();\n                const touch = evt.touches[0];\n                this.touchStartX = touch.clientX;\n                this.touchStartY = touch.clientY;\n                this.moving = true;\n            },\n            onTouchMove: function(evt) {\n                if (!this.moving) return;\n                evt.preventDefault();\n                const touch = evt.touches[0];\n                const deltaX = touch.clientX - this.touchStartX;\n                const deltaY = touch.clientY - this.touchStartY;\n                // Calculate movement direction\n                const rotation = this.el.object3D.rotation.y;\n                const moveX = Math.sin(rotation) * deltaY * this.speed + Math.cos(rotation) * deltaX * this.speed;\n                const moveZ = Math.cos(rotation) * deltaY * this.speed - Math.sin(rotation) * deltaX * this.speed;\n                // Update position\n                this.el.object3D.position.x += moveX * 0.01;\n                this.el.object3D.position.z += moveZ * 0.01;\n            },\n            onTouchEnd: function() {\n                this.moving = false;\n            },\n            onPinchStart: function(evt) {\n                if (evt.touches.length !== 2) return;\n                const touch1 = evt.touches[0];\n                const touch2 = evt.touches[1];\n                this.pinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);\n            },\n            onPinchMove: function(evt) {\n                if (evt.touches.length !== 2) return;\n                const touch1 = evt.touches[0];\n                const touch2 = evt.touches[1];\n                const newDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);\n                if (this.pinchDistance) {\n                    const delta = newDistance - this.pinchDistance;\n                    this.el.object3D.position.z += delta * 0.01;\n                }\n                this.pinchDistance = newDistance;\n            }\n        });\n    }\n};\nif (true) {\n    if (typeof AFRAME !== 'undefined') {\n        initMobileControls();\n    } else {\n        window.addEventListener('aframe-loaded', initMobileControls);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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L21vYmlsZS1jb250cm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbml0TW9iaWxlQ29udHJvbHMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQUZSQU1FICE9PSAndW5kZWZpbmVkJykge1xuICAgIEFGUkFNRS5yZWdpc3RlckNvbXBvbmVudCgnbW9iaWxlLWNvbnRyb2xzJywge1xuICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUFGUkFNRS51dGlscy5kZXZpY2UuaXNNb2JpbGUoKSkgcmV0dXJuOyAvLyBPbmx5IHJ1biBvbiBtb2JpbGVcbiAgICAgICAgXG4gICAgICAgIHRoaXMudG91Y2hTdGFydFggPSAwO1xuICAgICAgICB0aGlzLnRvdWNoU3RhcnRZID0gMDtcbiAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDAuMTU7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgRC1wYWQgVUlcbiAgICAgICAgY29uc3QgZHBhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkcGFkLmlkID0gJ21vYmlsZS1kcGFkJztcbiAgICAgICAgZHBhZC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICBib3R0b206IDIwcHg7XG4gICAgICAgICAgbGVmdDogMjBweDtcbiAgICAgICAgICB3aWR0aDogMTUwcHg7XG4gICAgICAgICAgaGVpZ2h0OiAxNTBweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICAgICAgdG91Y2gtYWN0aW9uOiBub25lO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcGFkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRvdWNoIGhhbmRsZXJzIGZvciBELXBhZFxuICAgICAgICBkcGFkLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgZHBhZC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBkcGFkLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcykpO1xuICAgICAgICBcbiAgICAgICAgLy8gUGluY2ggem9vbSBoYW5kbGVyc1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblBpbmNoU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25QaW5jaE1vdmUuYmluZCh0aGlzKSk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZ0LnRvdWNoZXNbMF07XG4gICAgICAgIHRoaXMudG91Y2hTdGFydFggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgICB0aGlzLnRvdWNoU3RhcnRZID0gdG91Y2guY2xpZW50WTtcbiAgICAgICAgdGhpcy5tb3ZpbmcgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdmluZykgcmV0dXJuO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZ0LnRvdWNoZXNbMF07XG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IHRvdWNoLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSB0b3VjaC5jbGllbnRZIC0gdGhpcy50b3VjaFN0YXJ0WTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBtb3ZlbWVudCBkaXJlY3Rpb25cbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmVsLm9iamVjdDNELnJvdGF0aW9uLnk7XG4gICAgICAgIGNvbnN0IG1vdmVYID0gTWF0aC5zaW4ocm90YXRpb24pICogZGVsdGFZICogdGhpcy5zcGVlZCArIE1hdGguY29zKHJvdGF0aW9uKSAqIGRlbHRhWCAqIHRoaXMuc3BlZWQ7XG4gICAgICAgIGNvbnN0IG1vdmVaID0gTWF0aC5jb3Mocm90YXRpb24pICogZGVsdGFZICogdGhpcy5zcGVlZCAtIE1hdGguc2luKHJvdGF0aW9uKSAqIGRlbHRhWCAqIHRoaXMuc3BlZWQ7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5lbC5vYmplY3QzRC5wb3NpdGlvbi54ICs9IG1vdmVYICogMC4wMTtcbiAgICAgICAgdGhpcy5lbC5vYmplY3QzRC5wb3NpdGlvbi56ICs9IG1vdmVaICogMC4wMTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIG9uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIG9uUGluY2hTdGFydDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAyKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0b3VjaDEgPSBldnQudG91Y2hlc1swXTtcbiAgICAgICAgY29uc3QgdG91Y2gyID0gZXZ0LnRvdWNoZXNbMV07XG4gICAgICAgIHRoaXMucGluY2hEaXN0YW5jZSA9IE1hdGguaHlwb3QoXG4gICAgICAgICAgdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgICB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBvblBpbmNoTW92ZTogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAyKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0b3VjaDEgPSBldnQudG91Y2hlc1swXTtcbiAgICAgICAgY29uc3QgdG91Y2gyID0gZXZ0LnRvdWNoZXNbMV07XG4gICAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5oeXBvdChcbiAgICAgICAgICB0b3VjaDIuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYLFxuICAgICAgICAgIHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFlcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnBpbmNoRGlzdGFuY2UpIHtcbiAgICAgICAgICBjb25zdCBkZWx0YSA9IG5ld0Rpc3RhbmNlIC0gdGhpcy5waW5jaERpc3RhbmNlO1xuICAgICAgICAgIHRoaXMuZWwub2JqZWN0M0QucG9zaXRpb24ueiArPSBkZWx0YSAqIDAuMDE7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMucGluY2hEaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiBBRlJBTUUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaW5pdE1vYmlsZUNvbnRyb2xzKCk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2FmcmFtZS1sb2FkZWQnLCBpbml0TW9iaWxlQ29udHJvbHMpO1xuICB9XG59ICJdLCJuYW1lcyI6WyJpbml0TW9iaWxlQ29udHJvbHMiLCJBRlJBTUUiLCJyZWdpc3RlckNvbXBvbmVudCIsImluaXQiLCJ1dGlscyIsImRldmljZSIsImlzTW9iaWxlIiwidG91Y2hTdGFydFgiLCJ0b3VjaFN0YXJ0WSIsIm1vdmluZyIsInNwZWVkIiwiZHBhZCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlkIiwic3R5bGUiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uVG91Y2hTdGFydCIsImJpbmQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJvblBpbmNoU3RhcnQiLCJvblBpbmNoTW92ZSIsImV2dCIsInByZXZlbnREZWZhdWx0IiwidG91Y2giLCJ0b3VjaGVzIiwiY2xpZW50WCIsImNsaWVudFkiLCJkZWx0YVgiLCJkZWx0YVkiLCJyb3RhdGlvbiIsImVsIiwib2JqZWN0M0QiLCJ5IiwibW92ZVgiLCJNYXRoIiwic2luIiwiY29zIiwibW92ZVoiLCJwb3NpdGlvbiIsIngiLCJ6IiwibGVuZ3RoIiwidG91Y2gxIiwidG91Y2gyIiwicGluY2hEaXN0YW5jZSIsImh5cG90IiwibmV3RGlzdGFuY2UiLCJkZWx0YSIsIndpbmRvdyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/mobile-controls.js\n"));

/***/ })

}]);