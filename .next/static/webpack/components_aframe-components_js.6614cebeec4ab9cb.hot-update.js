/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_aframe-components_js",{

/***/ "./components/aframe-components.js":
/*!*****************************************!*\
  !*** ./components/aframe-components.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Only run this code on the client side\nif (true) {\n    const nipplejs = __webpack_require__(/*! nipplejs */ \"./node_modules/nipplejs/dist/nipplejs.js\");\n    AFRAME.registerComponent('mobile-controls', {\n        init: function() {\n            // Mobile joystick controls\n            const joystickEl = document.createElement('div');\n            joystickEl.classList.add('joystick');\n            document.body.appendChild(joystickEl);\n            const joystick = nipplejs.create({\n                zone: joystickEl,\n                mode: 'static',\n                position: {\n                    left: '50px',\n                    bottom: '50px'\n                },\n                color: 'white'\n            });\n            const camera = this.el;\n            joystick.on('move', (evt, data)=>{\n                const speed = 0.1;\n                const x = Math.cos(data.angle.radian) * speed;\n                const z = Math.sin(data.angle.radian) * speed;\n                const pos = camera.getAttribute('position');\n                camera.setAttribute('position', {\n                    x: pos.x + x,\n                    y: pos.y,\n                    z: pos.z + z\n                });\n            });\n        }\n    });\n    AFRAME.registerComponent('parking-lot-texture', {\n        init: function() {\n            const canvas = document.getElementById('parkingTexture');\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            // Set background to white\n            ctx.fillStyle = '#FFFFFF';\n            ctx.fillRect(0, 0, 512, 512);\n            // Draw parking lines\n            ctx.strokeStyle = '#333333';\n            ctx.lineWidth = 4;\n            // Draw straight lines\n            for(let i = 0; i < 512; i += 64){\n                // Vertical lines\n                ctx.beginPath();\n                ctx.moveTo(i, 0);\n                ctx.lineTo(i, 512);\n                ctx.stroke();\n                // Horizontal lines\n                ctx.beginPath();\n                ctx.moveTo(0, i);\n                ctx.lineTo(512, i);\n                ctx.stroke();\n            }\n            // Draw squiggles\n            ctx.strokeStyle = '#222222';\n            ctx.lineWidth = 2;\n            for(let i = 0; i < 10; i++){\n                ctx.beginPath();\n                ctx.moveTo(Math.random() * 512, Math.random() * 512);\n                for(let j = 0; j < 5; j++){\n                    ctx.quadraticCurveTo(Math.random() * 512, Math.random() * 512, Math.random() * 512, Math.random() * 512);\n                }\n                ctx.stroke();\n            }\n        }\n    });\n    AFRAME.registerComponent('custom-controls', {\n        init: function() {\n            const camera = this.el;\n            let moveForward = false;\n            let moveBackward = false;\n            let moveLeft = false;\n            let moveRight = false;\n            const speed = 0.15;\n            // Create D-pad container\n            const dpadContainer = document.createElement('div');\n            dpadContainer.className = 'dpad-container';\n            const dpad = document.createElement('div');\n            dpad.className = 'dpad';\n            // Create D-pad buttons\n            const buttons = {\n                up: createButton('dpad-up'),\n                right: createButton('dpad-right'),\n                down: createButton('dpad-down'),\n                left: createButton('dpad-left')\n            };\n            function createButton(className) {\n                const button = document.createElement('div');\n                button.className = \"dpad-button \".concat(className);\n                dpad.appendChild(button);\n                return button;\n            }\n            // Add touch event listeners\n            buttons.up.addEventListener('touchstart', ()=>moveForward = true);\n            buttons.up.addEventListener('touchend', ()=>moveForward = false);\n            buttons.down.addEventListener('touchstart', ()=>moveBackward = true);\n            buttons.down.addEventListener('touchend', ()=>moveBackward = false);\n            buttons.left.addEventListener('touchstart', ()=>moveLeft = true);\n            buttons.left.addEventListener('touchend', ()=>moveLeft = false);\n            buttons.right.addEventListener('touchstart', ()=>moveRight = true);\n            buttons.right.addEventListener('touchend', ()=>moveRight = false);\n            dpadContainer.appendChild(dpad);\n            document.body.appendChild(dpadContainer);\n            // Movement animation\n            this.tick = function() {\n                const rotation = camera.object3D.rotation;\n                const position = camera.object3D.position;\n                // Calculate forward direction based on camera rotation\n                const direction = new THREE.Vector3();\n                camera.object3D.getWorldDirection(direction);\n                if (moveForward) {\n                    position.x += direction.x * speed;\n                    position.z += direction.z * speed;\n                }\n                if (moveBackward) {\n                    position.x -= direction.x * speed;\n                    position.z -= direction.z * speed;\n                }\n                if (moveLeft) {\n                    position.x += Math.cos(rotation.y + Math.PI / 2) * speed;\n                    position.z += Math.sin(rotation.y + Math.PI / 2) * speed;\n                }\n                if (moveRight) {\n                    position.x += Math.cos(rotation.y - Math.PI / 2) * speed;\n                    position.z += Math.sin(rotation.y - Math.PI / 2) * speed;\n                }\n            };\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxFQUFFLEdBQUMsS0FBS2pEO2dCQUNuRDtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9tcm1ldGF2ZXJzZS9Db2RlL2J1ZmZibGV1L2NvbXBvbmVudHMvYWZyYW1lLWNvbXBvbmVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT25seSBydW4gdGhpcyBjb2RlIG9uIHRoZSBjbGllbnQgc2lkZVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbnN0IG5pcHBsZWpzID0gcmVxdWlyZSgnbmlwcGxlanMnKTtcblxuICBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ21vYmlsZS1jb250cm9scycsIHtcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBNb2JpbGUgam95c3RpY2sgY29udHJvbHNcbiAgICAgIGNvbnN0IGpveXN0aWNrRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGpveXN0aWNrRWwuY2xhc3NMaXN0LmFkZCgnam95c3RpY2snKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoam95c3RpY2tFbCk7XG5cbiAgICAgIGNvbnN0IGpveXN0aWNrID0gbmlwcGxlanMuY3JlYXRlKHtcbiAgICAgICAgem9uZTogam95c3RpY2tFbCxcbiAgICAgICAgbW9kZTogJ3N0YXRpYycsXG4gICAgICAgIHBvc2l0aW9uOiB7IGxlZnQ6ICc1MHB4JywgYm90dG9tOiAnNTBweCcgfSxcbiAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5lbDtcbiAgICAgIGpveXN0aWNrLm9uKCdtb3ZlJywgKGV2dCwgZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBzcGVlZCA9IDAuMTtcbiAgICAgICAgY29uc3QgeCA9IE1hdGguY29zKGRhdGEuYW5nbGUucmFkaWFuKSAqIHNwZWVkO1xuICAgICAgICBjb25zdCB6ID0gTWF0aC5zaW4oZGF0YS5hbmdsZS5yYWRpYW4pICogc3BlZWQ7XG4gICAgICAgIGNvbnN0IHBvcyA9IGNhbWVyYS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIGNhbWVyYS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywge1xuICAgICAgICAgIHg6IHBvcy54ICsgeCxcbiAgICAgICAgICB5OiBwb3MueSxcbiAgICAgICAgICB6OiBwb3MueiArIHosXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBBRlJBTUUucmVnaXN0ZXJDb21wb25lbnQoJ3BhcmtpbmctbG90LXRleHR1cmUnLCB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFya2luZ1RleHR1cmUnKTtcbiAgICAgIGlmICghY2FudmFzKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgXG4gICAgICAvLyBTZXQgYmFja2dyb3VuZCB0byB3aGl0ZVxuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjRkZGRkZGJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCA1MTIsIDUxMik7XG4gICAgICBcbiAgICAgIC8vIERyYXcgcGFya2luZyBsaW5lc1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyMzMzMzMzMnO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDQ7XG4gICAgICBcbiAgICAgIC8vIERyYXcgc3RyYWlnaHQgbGluZXNcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCA1MTI7IGkgKz0gNjQpIHtcbiAgICAgICAgLy8gVmVydGljYWwgbGluZXNcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGksIDApO1xuICAgICAgICBjdHgubGluZVRvKGksIDUxMik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEhvcml6b250YWwgbGluZXNcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIGkpO1xuICAgICAgICBjdHgubGluZVRvKDUxMiwgaSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRHJhdyBzcXVpZ2dsZXNcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjMjIyMjIyJztcbiAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKE1hdGgucmFuZG9tKCkgKiA1MTIsIE1hdGgucmFuZG9tKCkgKiA1MTIpO1xuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgNTsgaisrKSB7XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogNTEyLCBNYXRoLnJhbmRvbSgpICogNTEyLFxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIDUxMiwgTWF0aC5yYW5kb20oKSAqIDUxMlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdjdXN0b20tY29udHJvbHMnLCB7XG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5lbDtcbiAgICAgIGxldCBtb3ZlRm9yd2FyZCA9IGZhbHNlO1xuICAgICAgbGV0IG1vdmVCYWNrd2FyZCA9IGZhbHNlO1xuICAgICAgbGV0IG1vdmVMZWZ0ID0gZmFsc2U7XG4gICAgICBsZXQgbW92ZVJpZ2h0ID0gZmFsc2U7XG4gICAgICBjb25zdCBzcGVlZCA9IDAuMTU7XG5cbiAgICAgIC8vIENyZWF0ZSBELXBhZCBjb250YWluZXJcbiAgICAgIGNvbnN0IGRwYWRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRwYWRDb250YWluZXIuY2xhc3NOYW1lID0gJ2RwYWQtY29udGFpbmVyJztcbiAgICAgIFxuICAgICAgY29uc3QgZHBhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZHBhZC5jbGFzc05hbWUgPSAnZHBhZCc7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBELXBhZCBidXR0b25zXG4gICAgICBjb25zdCBidXR0b25zID0ge1xuICAgICAgICB1cDogY3JlYXRlQnV0dG9uKCdkcGFkLXVwJyksXG4gICAgICAgIHJpZ2h0OiBjcmVhdGVCdXR0b24oJ2RwYWQtcmlnaHQnKSxcbiAgICAgICAgZG93bjogY3JlYXRlQnV0dG9uKCdkcGFkLWRvd24nKSxcbiAgICAgICAgbGVmdDogY3JlYXRlQnV0dG9uKCdkcGFkLWxlZnQnKVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9IGBkcGFkLWJ1dHRvbiAke2NsYXNzTmFtZX1gO1xuICAgICAgICBkcGFkLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0b3VjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAgIGJ1dHRvbnMudXAuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsICgpID0+IG1vdmVGb3J3YXJkID0gdHJ1ZSk7XG4gICAgICBidXR0b25zLnVwLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKCkgPT4gbW92ZUZvcndhcmQgPSBmYWxzZSk7XG4gICAgICBcbiAgICAgIGJ1dHRvbnMuZG93bi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKCkgPT4gbW92ZUJhY2t3YXJkID0gdHJ1ZSk7XG4gICAgICBidXR0b25zLmRvd24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoKSA9PiBtb3ZlQmFja3dhcmQgPSBmYWxzZSk7XG4gICAgICBcbiAgICAgIGJ1dHRvbnMubGVmdC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKCkgPT4gbW92ZUxlZnQgPSB0cnVlKTtcbiAgICAgIGJ1dHRvbnMubGVmdC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IG1vdmVMZWZ0ID0gZmFsc2UpO1xuICAgICAgXG4gICAgICBidXR0b25zLnJpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoKSA9PiBtb3ZlUmlnaHQgPSB0cnVlKTtcbiAgICAgIGJ1dHRvbnMucmlnaHQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoKSA9PiBtb3ZlUmlnaHQgPSBmYWxzZSk7XG5cbiAgICAgIGRwYWRDb250YWluZXIuYXBwZW5kQ2hpbGQoZHBhZCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRwYWRDb250YWluZXIpO1xuXG4gICAgICAvLyBNb3ZlbWVudCBhbmltYXRpb25cbiAgICAgIHRoaXMudGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNhbWVyYS5vYmplY3QzRC5yb3RhdGlvbjtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBjYW1lcmEub2JqZWN0M0QucG9zaXRpb247XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZm9yd2FyZCBkaXJlY3Rpb24gYmFzZWQgb24gY2FtZXJhIHJvdGF0aW9uXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIGNhbWVyYS5vYmplY3QzRC5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICBcbiAgICAgICAgaWYgKG1vdmVGb3J3YXJkKSB7XG4gICAgICAgICAgcG9zaXRpb24ueCArPSBkaXJlY3Rpb24ueCAqIHNwZWVkO1xuICAgICAgICAgIHBvc2l0aW9uLnogKz0gZGlyZWN0aW9uLnogKiBzcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZUJhY2t3YXJkKSB7XG4gICAgICAgICAgcG9zaXRpb24ueCAtPSBkaXJlY3Rpb24ueCAqIHNwZWVkO1xuICAgICAgICAgIHBvc2l0aW9uLnogLT0gZGlyZWN0aW9uLnogKiBzcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZUxlZnQpIHtcbiAgICAgICAgICBwb3NpdGlvbi54ICs9IE1hdGguY29zKHJvdGF0aW9uLnkgKyBNYXRoLlBJLzIpICogc3BlZWQ7XG4gICAgICAgICAgcG9zaXRpb24ueiArPSBNYXRoLnNpbihyb3RhdGlvbi55ICsgTWF0aC5QSS8yKSAqIHNwZWVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlUmlnaHQpIHtcbiAgICAgICAgICBwb3NpdGlvbi54ICs9IE1hdGguY29zKHJvdGF0aW9uLnkgLSBNYXRoLlBJLzIpICogc3BlZWQ7XG4gICAgICAgICAgcG9zaXRpb24ueiArPSBNYXRoLnNpbihyb3RhdGlvbi55IC0gTWF0aC5QSS8yKSAqIHNwZWVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59ICJdLCJuYW1lcyI6WyJuaXBwbGVqcyIsInJlcXVpcmUiLCJBRlJBTUUiLCJyZWdpc3RlckNvbXBvbmVudCIsImluaXQiLCJqb3lzdGlja0VsIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiam95c3RpY2siLCJjcmVhdGUiLCJ6b25lIiwibW9kZSIsInBvc2l0aW9uIiwibGVmdCIsImJvdHRvbSIsImNvbG9yIiwiY2FtZXJhIiwiZWwiLCJvbiIsImV2dCIsImRhdGEiLCJzcGVlZCIsIngiLCJNYXRoIiwiY29zIiwiYW5nbGUiLCJyYWRpYW4iLCJ6Iiwic2luIiwicG9zIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwieSIsImNhbnZhcyIsImdldEVsZW1lbnRCeUlkIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0Iiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJpIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwicmFuZG9tIiwiaiIsInF1YWRyYXRpY0N1cnZlVG8iLCJtb3ZlRm9yd2FyZCIsIm1vdmVCYWNrd2FyZCIsIm1vdmVMZWZ0IiwibW92ZVJpZ2h0IiwiZHBhZENvbnRhaW5lciIsImNsYXNzTmFtZSIsImRwYWQiLCJidXR0b25zIiwidXAiLCJjcmVhdGVCdXR0b24iLCJyaWdodCIsImRvd24iLCJidXR0b24iLCJhZGRFdmVudExpc3RlbmVyIiwidGljayIsInJvdGF0aW9uIiwib2JqZWN0M0QiLCJkaXJlY3Rpb24iLCJUSFJFRSIsIlZlY3RvcjMiLCJnZXRXb3JsZERpcmVjdGlvbiIsIlBJIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/aframe-components.js\n"));

/***/ })

});