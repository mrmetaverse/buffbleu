/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_aframe-components_js",{

/***/ "./components/aframe-components.js":
/*!*****************************************!*\
  !*** ./components/aframe-components.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Only run this code on the client side\nif (true) {\n    // Import THREE from A-Frame to use for vector calculations\n    const THREE = AFRAME.THREE;\n    AFRAME.registerComponent('custom-controls', {\n        init: function() {\n            const camera = this.el;\n            let moveForward = false;\n            let moveBackward = false;\n            let moveLeft = false;\n            let moveRight = false;\n            const speed = 0.15;\n            // Create D-pad container\n            const dpadContainer = document.createElement('div');\n            dpadContainer.className = 'dpad-container';\n            const dpad = document.createElement('div');\n            dpad.className = 'dpad';\n            // Create D-pad buttons with icons\n            const buttons = {\n                up: createButton('dpad-up', '↑'),\n                right: createButton('dpad-right', '→'),\n                down: createButton('dpad-down', '↓'),\n                left: createButton('dpad-left', '←')\n            };\n            function createButton(className, icon) {\n                const button = document.createElement('div');\n                button.className = \"dpad-button \".concat(className);\n                button.innerHTML = icon;\n                dpad.appendChild(button);\n                return button;\n            }\n            // Add touch event listeners with prevent default\n            const addTouchListeners = (element, callback)=>{\n                element.addEventListener('touchstart', (e)=>{\n                    e.preventDefault();\n                    callback(true);\n                }, {\n                    passive: false\n                });\n                element.addEventListener('touchend', (e)=>{\n                    e.preventDefault();\n                    callback(false);\n                }, {\n                    passive: false\n                });\n            };\n            addTouchListeners(buttons.up, (val)=>moveForward = val);\n            addTouchListeners(buttons.down, (val)=>moveBackward = val);\n            addTouchListeners(buttons.left, (val)=>moveLeft = val);\n            addTouchListeners(buttons.right, (val)=>moveRight = val);\n            dpadContainer.appendChild(dpad);\n            document.body.appendChild(dpadContainer);\n            // Movement animation\n            this.tick = function() {\n                const rotation = camera.object3D.rotation;\n                const position = camera.object3D.position;\n                // Calculate forward direction based on camera rotation\n                const direction = new THREE.Vector3();\n                camera.object3D.getWorldDirection(direction);\n                if (moveForward) {\n                    position.x += direction.x * speed;\n                    position.z += direction.z * speed;\n                }\n                if (moveBackward) {\n                    position.x -= direction.x * speed;\n                    position.z -= direction.z * speed;\n                }\n                if (moveLeft) {\n                    position.x += Math.cos(rotation.y + Math.PI / 2) * speed;\n                    position.z += Math.sin(rotation.y + Math.PI / 2) * speed;\n                }\n                if (moveRight) {\n                    position.x += Math.cos(rotation.y - Math.PI / 2) * speed;\n                    position.z += Math.sin(rotation.y - Math.PI / 2) * speed;\n                }\n            };\n        }\n    });\n    AFRAME.registerComponent('parking-lot-texture', {\n        init: function() {\n            const canvas = document.getElementById('parkingTexture');\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            // Set background to white\n            ctx.fillStyle = '#FFFFFF';\n            ctx.fillRect(0, 0, 512, 512);\n            // Draw parking lines\n            ctx.strokeStyle = '#333333';\n            ctx.lineWidth = 4;\n            // Draw straight lines\n            for(let i = 0; i < 512; i += 64){\n                // Vertical lines\n                ctx.beginPath();\n                ctx.moveTo(i, 0);\n                ctx.lineTo(i, 512);\n                ctx.stroke();\n                // Horizontal lines\n                ctx.beginPath();\n                ctx.moveTo(0, i);\n                ctx.lineTo(512, i);\n                ctx.stroke();\n            }\n            // Draw squiggles\n            ctx.strokeStyle = '#222222';\n            ctx.lineWidth = 2;\n            for(let i = 0; i < 10; i++){\n                ctx.beginPath();\n                ctx.moveTo(Math.random() * 512, Math.random() * 512);\n                for(let j = 0; j < 5; j++){\n                    ctx.quadraticCurveTo(Math.random() * 512, Math.random() * 512, Math.random() * 512, Math.random() * 512);\n                }\n                ctx.stroke();\n            }\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2FmcmFtZS1jb21wb25lbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLHdDQUF3QztBQUN4QyxJQUFJLElBQTZCLEVBQUU7SUFDakMsMkRBQTJEO0lBQzNELE1BQU1BLFFBQVFDLE9BQU9ELEtBQUs7SUFFMUJDLE9BQU9DLGlCQUFpQixDQUFDLG1CQUFtQjtRQUMxQ0MsTUFBTTtZQUNKLE1BQU1DLFNBQVMsSUFBSSxDQUFDQyxFQUFFO1lBQ3RCLElBQUlDLGNBQWM7WUFDbEIsSUFBSUMsZUFBZTtZQUNuQixJQUFJQyxXQUFXO1lBQ2YsSUFBSUMsWUFBWTtZQUNoQixNQUFNQyxRQUFRO1lBRWQseUJBQXlCO1lBQ3pCLE1BQU1DLGdCQUFnQkMsU0FBU0MsYUFBYSxDQUFDO1lBQzdDRixjQUFjRyxTQUFTLEdBQUc7WUFFMUIsTUFBTUMsT0FBT0gsU0FBU0MsYUFBYSxDQUFDO1lBQ3BDRSxLQUFLRCxTQUFTLEdBQUc7WUFFakIsa0NBQWtDO1lBQ2xDLE1BQU1FLFVBQVU7Z0JBQ2RDLElBQUlDLGFBQWEsV0FBVztnQkFDNUJDLE9BQU9ELGFBQWEsY0FBYztnQkFDbENFLE1BQU1GLGFBQWEsYUFBYTtnQkFDaENHLE1BQU1ILGFBQWEsYUFBYTtZQUNsQztZQUVBLFNBQVNBLGFBQWFKLFNBQVMsRUFBRVEsSUFBSTtnQkFDbkMsTUFBTUMsU0FBU1gsU0FBU0MsYUFBYSxDQUFDO2dCQUN0Q1UsT0FBT1QsU0FBUyxHQUFHLGVBQXlCLE9BQVZBO2dCQUNsQ1MsT0FBT0MsU0FBUyxHQUFHRjtnQkFDbkJQLEtBQUtVLFdBQVcsQ0FBQ0Y7Z0JBQ2pCLE9BQU9BO1lBQ1Q7WUFFQSxpREFBaUQ7WUFDakQsTUFBTUcsb0JBQW9CLENBQUNDLFNBQVNDO2dCQUNsQ0QsUUFBUUUsZ0JBQWdCLENBQUMsY0FBYyxDQUFDQztvQkFDdENBLEVBQUVDLGNBQWM7b0JBQ2hCSCxTQUFTO2dCQUNYLEdBQUc7b0JBQUVJLFNBQVM7Z0JBQU07Z0JBRXBCTCxRQUFRRSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUNDO29CQUNwQ0EsRUFBRUMsY0FBYztvQkFDaEJILFNBQVM7Z0JBQ1gsR0FBRztvQkFBRUksU0FBUztnQkFBTTtZQUN0QjtZQUVBTixrQkFBa0JWLFFBQVFDLEVBQUUsRUFBRSxDQUFDZ0IsTUFBUTNCLGNBQWMyQjtZQUNyRFAsa0JBQWtCVixRQUFRSSxJQUFJLEVBQUUsQ0FBQ2EsTUFBUTFCLGVBQWUwQjtZQUN4RFAsa0JBQWtCVixRQUFRSyxJQUFJLEVBQUUsQ0FBQ1ksTUFBUXpCLFdBQVd5QjtZQUNwRFAsa0JBQWtCVixRQUFRRyxLQUFLLEVBQUUsQ0FBQ2MsTUFBUXhCLFlBQVl3QjtZQUV0RHRCLGNBQWNjLFdBQVcsQ0FBQ1Y7WUFDMUJILFNBQVNzQixJQUFJLENBQUNULFdBQVcsQ0FBQ2Q7WUFFMUIscUJBQXFCO1lBQ3JCLElBQUksQ0FBQ3dCLElBQUksR0FBRztnQkFDVixNQUFNQyxXQUFXaEMsT0FBT2lDLFFBQVEsQ0FBQ0QsUUFBUTtnQkFDekMsTUFBTUUsV0FBV2xDLE9BQU9pQyxRQUFRLENBQUNDLFFBQVE7Z0JBRXpDLHVEQUF1RDtnQkFDdkQsTUFBTUMsWUFBWSxJQUFJdkMsTUFBTXdDLE9BQU87Z0JBQ25DcEMsT0FBT2lDLFFBQVEsQ0FBQ0ksaUJBQWlCLENBQUNGO2dCQUVsQyxJQUFJakMsYUFBYTtvQkFDZmdDLFNBQVNJLENBQUMsSUFBSUgsVUFBVUcsQ0FBQyxHQUFHaEM7b0JBQzVCNEIsU0FBU0ssQ0FBQyxJQUFJSixVQUFVSSxDQUFDLEdBQUdqQztnQkFDOUI7Z0JBQ0EsSUFBSUgsY0FBYztvQkFDaEIrQixTQUFTSSxDQUFDLElBQUlILFVBQVVHLENBQUMsR0FBR2hDO29CQUM1QjRCLFNBQVNLLENBQUMsSUFBSUosVUFBVUksQ0FBQyxHQUFHakM7Z0JBQzlCO2dCQUNBLElBQUlGLFVBQVU7b0JBQ1o4QixTQUFTSSxDQUFDLElBQUlFLEtBQUtDLEdBQUcsQ0FBQ1QsU0FBU1UsQ0FBQyxHQUFHRixLQUFLRyxFQUFFLEdBQUMsS0FBS3JDO29CQUNqRDRCLFNBQVNLLENBQUMsSUFBSUMsS0FBS0ksR0FBRyxDQUFDWixTQUFTVSxDQUFDLEdBQUdGLEtBQUtHLEVBQUUsR0FBQyxLQUFLckM7Z0JBQ25EO2dCQUNBLElBQUlELFdBQVc7b0JBQ2I2QixTQUFTSSxDQUFDLElBQUlFLEtBQUtDLEdBQUcsQ0FBQ1QsU0FBU1UsQ0FBQyxHQUFHRixLQUFLRyxFQUFFLEdBQUMsS0FBS3JDO29CQUNqRDRCLFNBQVNLLENBQUMsSUFBSUMsS0FBS0ksR0FBRyxDQUFDWixTQUFTVSxDQUFDLEdBQUdGLEtBQUtHLEVBQUUsR0FBQyxLQUFLckM7Z0JBQ25EO1lBQ0Y7UUFDRjtJQUNGO0lBRUFULE9BQU9DLGlCQUFpQixDQUFDLHVCQUF1QjtRQUM5Q0MsTUFBTTtZQUNKLE1BQU04QyxTQUFTckMsU0FBU3NDLGNBQWMsQ0FBQztZQUN2QyxJQUFJLENBQUNELFFBQVE7WUFFYixNQUFNRSxNQUFNRixPQUFPRyxVQUFVLENBQUM7WUFFOUIsMEJBQTBCO1lBQzFCRCxJQUFJRSxTQUFTLEdBQUc7WUFDaEJGLElBQUlHLFFBQVEsQ0FBQyxHQUFHLEdBQUcsS0FBSztZQUV4QixxQkFBcUI7WUFDckJILElBQUlJLFdBQVcsR0FBRztZQUNsQkosSUFBSUssU0FBUyxHQUFHO1lBRWhCLHNCQUFzQjtZQUN0QixJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLQSxLQUFLLEdBQUk7Z0JBQy9CLGlCQUFpQjtnQkFDakJOLElBQUlPLFNBQVM7Z0JBQ2JQLElBQUlRLE1BQU0sQ0FBQ0YsR0FBRztnQkFDZE4sSUFBSVMsTUFBTSxDQUFDSCxHQUFHO2dCQUNkTixJQUFJVSxNQUFNO2dCQUVWLG1CQUFtQjtnQkFDbkJWLElBQUlPLFNBQVM7Z0JBQ2JQLElBQUlRLE1BQU0sQ0FBQyxHQUFHRjtnQkFDZE4sSUFBSVMsTUFBTSxDQUFDLEtBQUtIO2dCQUNoQk4sSUFBSVUsTUFBTTtZQUNaO1lBRUEsaUJBQWlCO1lBQ2pCVixJQUFJSSxXQUFXLEdBQUc7WUFDbEJKLElBQUlLLFNBQVMsR0FBRztZQUNoQixJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO2dCQUMxQk4sSUFBSU8sU0FBUztnQkFDYlAsSUFBSVEsTUFBTSxDQUFDZixLQUFLa0IsTUFBTSxLQUFLLEtBQUtsQixLQUFLa0IsTUFBTSxLQUFLO2dCQUNoRCxJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO29CQUN6QlosSUFBSWEsZ0JBQWdCLENBQ2xCcEIsS0FBS2tCLE1BQU0sS0FBSyxLQUFLbEIsS0FBS2tCLE1BQU0sS0FBSyxLQUNyQ2xCLEtBQUtrQixNQUFNLEtBQUssS0FBS2xCLEtBQUtrQixNQUFNLEtBQUs7Z0JBRXpDO2dCQUNBWCxJQUFJVSxNQUFNO1lBQ1o7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL21ybWV0YXZlcnNlL0NvZGUvYnVmZmJsZXUvY29tcG9uZW50cy9hZnJhbWUtY29tcG9uZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPbmx5IHJ1biB0aGlzIGNvZGUgb24gdGhlIGNsaWVudCBzaWRlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gSW1wb3J0IFRIUkVFIGZyb20gQS1GcmFtZSB0byB1c2UgZm9yIHZlY3RvciBjYWxjdWxhdGlvbnNcbiAgY29uc3QgVEhSRUUgPSBBRlJBTUUuVEhSRUU7XG5cbiAgQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdjdXN0b20tY29udHJvbHMnLCB7XG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5lbDtcbiAgICAgIGxldCBtb3ZlRm9yd2FyZCA9IGZhbHNlO1xuICAgICAgbGV0IG1vdmVCYWNrd2FyZCA9IGZhbHNlO1xuICAgICAgbGV0IG1vdmVMZWZ0ID0gZmFsc2U7XG4gICAgICBsZXQgbW92ZVJpZ2h0ID0gZmFsc2U7XG4gICAgICBjb25zdCBzcGVlZCA9IDAuMTU7XG5cbiAgICAgIC8vIENyZWF0ZSBELXBhZCBjb250YWluZXJcbiAgICAgIGNvbnN0IGRwYWRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRwYWRDb250YWluZXIuY2xhc3NOYW1lID0gJ2RwYWQtY29udGFpbmVyJztcbiAgICAgIFxuICAgICAgY29uc3QgZHBhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZHBhZC5jbGFzc05hbWUgPSAnZHBhZCc7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBELXBhZCBidXR0b25zIHdpdGggaWNvbnNcbiAgICAgIGNvbnN0IGJ1dHRvbnMgPSB7XG4gICAgICAgIHVwOiBjcmVhdGVCdXR0b24oJ2RwYWQtdXAnLCAn4oaRJyksXG4gICAgICAgIHJpZ2h0OiBjcmVhdGVCdXR0b24oJ2RwYWQtcmlnaHQnLCAn4oaSJyksXG4gICAgICAgIGRvd246IGNyZWF0ZUJ1dHRvbignZHBhZC1kb3duJywgJ+KGkycpLFxuICAgICAgICBsZWZ0OiBjcmVhdGVCdXR0b24oJ2RwYWQtbGVmdCcsICfihpAnKVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSwgaWNvbikge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9IGBkcGFkLWJ1dHRvbiAke2NsYXNzTmFtZX1gO1xuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gaWNvbjtcbiAgICAgICAgZHBhZC5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdG91Y2ggZXZlbnQgbGlzdGVuZXJzIHdpdGggcHJldmVudCBkZWZhdWx0XG4gICAgICBjb25zdCBhZGRUb3VjaExpc3RlbmVycyA9IChlbGVtZW50LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCAoZSkgPT4ge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICB9O1xuXG4gICAgICBhZGRUb3VjaExpc3RlbmVycyhidXR0b25zLnVwLCAodmFsKSA9PiBtb3ZlRm9yd2FyZCA9IHZhbCk7XG4gICAgICBhZGRUb3VjaExpc3RlbmVycyhidXR0b25zLmRvd24sICh2YWwpID0+IG1vdmVCYWNrd2FyZCA9IHZhbCk7XG4gICAgICBhZGRUb3VjaExpc3RlbmVycyhidXR0b25zLmxlZnQsICh2YWwpID0+IG1vdmVMZWZ0ID0gdmFsKTtcbiAgICAgIGFkZFRvdWNoTGlzdGVuZXJzKGJ1dHRvbnMucmlnaHQsICh2YWwpID0+IG1vdmVSaWdodCA9IHZhbCk7XG5cbiAgICAgIGRwYWRDb250YWluZXIuYXBwZW5kQ2hpbGQoZHBhZCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRwYWRDb250YWluZXIpO1xuXG4gICAgICAvLyBNb3ZlbWVudCBhbmltYXRpb25cbiAgICAgIHRoaXMudGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNhbWVyYS5vYmplY3QzRC5yb3RhdGlvbjtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBjYW1lcmEub2JqZWN0M0QucG9zaXRpb247XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZm9yd2FyZCBkaXJlY3Rpb24gYmFzZWQgb24gY2FtZXJhIHJvdGF0aW9uXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIGNhbWVyYS5vYmplY3QzRC5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICBcbiAgICAgICAgaWYgKG1vdmVGb3J3YXJkKSB7XG4gICAgICAgICAgcG9zaXRpb24ueCArPSBkaXJlY3Rpb24ueCAqIHNwZWVkO1xuICAgICAgICAgIHBvc2l0aW9uLnogKz0gZGlyZWN0aW9uLnogKiBzcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZUJhY2t3YXJkKSB7XG4gICAgICAgICAgcG9zaXRpb24ueCAtPSBkaXJlY3Rpb24ueCAqIHNwZWVkO1xuICAgICAgICAgIHBvc2l0aW9uLnogLT0gZGlyZWN0aW9uLnogKiBzcGVlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZUxlZnQpIHtcbiAgICAgICAgICBwb3NpdGlvbi54ICs9IE1hdGguY29zKHJvdGF0aW9uLnkgKyBNYXRoLlBJLzIpICogc3BlZWQ7XG4gICAgICAgICAgcG9zaXRpb24ueiArPSBNYXRoLnNpbihyb3RhdGlvbi55ICsgTWF0aC5QSS8yKSAqIHNwZWVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlUmlnaHQpIHtcbiAgICAgICAgICBwb3NpdGlvbi54ICs9IE1hdGguY29zKHJvdGF0aW9uLnkgLSBNYXRoLlBJLzIpICogc3BlZWQ7XG4gICAgICAgICAgcG9zaXRpb24ueiArPSBNYXRoLnNpbihyb3RhdGlvbi55IC0gTWF0aC5QSS8yKSAqIHNwZWVkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdwYXJraW5nLWxvdC10ZXh0dXJlJywge1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmtpbmdUZXh0dXJlJyk7XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgICAgXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGJhY2tncm91bmQgdG8gd2hpdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnI0ZGRkZGRic7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgNTEyLCA1MTIpO1xuICAgICAgXG4gICAgICAvLyBEcmF3IHBhcmtpbmcgbGluZXNcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjMzMzMzMzJztcbiAgICAgIGN0eC5saW5lV2lkdGggPSA0O1xuICAgICAgXG4gICAgICAvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgNTEyOyBpICs9IDY0KSB7XG4gICAgICAgIC8vIFZlcnRpY2FsIGxpbmVzXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhpLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbyhpLCA1MTIpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmVzXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCBpKTtcbiAgICAgICAgY3R4LmxpbmVUbyg1MTIsIGkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERyYXcgc3F1aWdnbGVzXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzIyMjIyMic7XG4gICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhNYXRoLnJhbmRvbSgpICogNTEyLCBNYXRoLnJhbmRvbSgpICogNTEyKTtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IDU7IGorKykge1xuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIDUxMiwgTWF0aC5yYW5kb20oKSAqIDUxMixcbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiA1MTIsIE1hdGgucmFuZG9tKCkgKiA1MTJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSAiXSwibmFtZXMiOlsiVEhSRUUiLCJBRlJBTUUiLCJyZWdpc3RlckNvbXBvbmVudCIsImluaXQiLCJjYW1lcmEiLCJlbCIsIm1vdmVGb3J3YXJkIiwibW92ZUJhY2t3YXJkIiwibW92ZUxlZnQiLCJtb3ZlUmlnaHQiLCJzcGVlZCIsImRwYWRDb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJkcGFkIiwiYnV0dG9ucyIsInVwIiwiY3JlYXRlQnV0dG9uIiwicmlnaHQiLCJkb3duIiwibGVmdCIsImljb24iLCJidXR0b24iLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsImFkZFRvdWNoTGlzdGVuZXJzIiwiZWxlbWVudCIsImNhbGxiYWNrIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInBhc3NpdmUiLCJ2YWwiLCJib2R5IiwidGljayIsInJvdGF0aW9uIiwib2JqZWN0M0QiLCJwb3NpdGlvbiIsImRpcmVjdGlvbiIsIlZlY3RvcjMiLCJnZXRXb3JsZERpcmVjdGlvbiIsIngiLCJ6IiwiTWF0aCIsImNvcyIsInkiLCJQSSIsInNpbiIsImNhbnZhcyIsImdldEVsZW1lbnRCeUlkIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0Iiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJpIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwicmFuZG9tIiwiaiIsInF1YWRyYXRpY0N1cnZlVG8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/aframe-components.js\n"));

/***/ })

});